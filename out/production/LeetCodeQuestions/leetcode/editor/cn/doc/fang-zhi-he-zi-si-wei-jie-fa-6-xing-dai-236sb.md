*样例带给我们的启示已经很明显了...*

放置盒子的策略就是：**贴着墙角、尽可能高**。

按照题目的要求，最终摆出来的就是样例三这样。第一层有 1 个，第二层有 1 + 2 = 3 个，第三层有 1 + 2 + 3 = 6 个... 但是我们放置的顺序不是一层一层地放的，而是一行一行地放，每一次在底儿上增加 1 个盒子，然后就可以在上面堆叠一些，用坐标系表示放置盒子的顺序如下：

| 接触地面的盒子数量 | 盒子总数 | 相比上一行增加的盒子坐标            |
| :----------------: | :------: | ----------------------------------- |
|         1          |    1     | `(0, 0, 0)`                         |
|         2          |    2     | `(1, 0, 0)`                         |
|         3          |    4     | `(0, 1, 0)` `(0, 0, 1)`             |
|         4          |    5     | `(2, 0, 0)`                         |
|         5          |    7     | `(1, 1, 0)` `(1, 0, 1)`             |
|         6          |    10    | `(0, 2, 0)` `(0, 1, 1)` `(0, 0, 2)` |
|         7          |    11    | `(3, 0, 0)`                         |

上表中接触地面盒子数量为 3 和 6 时，对应的就是样例 2 和样例 3. 我们可以发现，从 0 开始，与地面接触的盒子每增加一个，可以放置的总盒子数就会增加 `1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5 ...` 个。

```java
class Solution {
    public int minimumBoxes(int n) {
        int bottom = 1;
        for (int sum = 1, height = 1; sum < n; height++) {
            for (int i = 0; i <= height && sum < n; i++) { // 每次增加 1 个底部盒子
                bottom++;
                sum += i + 1; // i 个是在上方堆叠的，不与地面接触
            }
        }
        return bottom;
    }
}
```

*(不算花括号) 其实，再把 `bottom++` 放到 `i++` 后面就又少一行。但是，拒绝玄学压行，维护可读性从我做起 -_-*

BTW 按照这个思路，性能还有进一步优化的空间，用用通项公式、二分啥的。不过运行效率的提升带来的就是编码效率的降低，这 6 行代码写起来多快 😊