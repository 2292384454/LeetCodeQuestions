    class Solution {
        public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
            Deque<Long> stack = new LinkedList<>();
            stack.push(0L);
            // mask1：保留高32位，即取得第一个杯子里的水
            // mask2：保留低32位，即取得第二个杯子里的水
            long mask2 = 0xffffffffL, mask1 = ~mask2;
            HashSet<Long> visited = new HashSet<>();
            while (!stack.isEmpty()) {
                Long cur = stack.pop();
                long contain1 = (cur & mask1) >> 32, contain2 = cur & mask2;
                if (contain1 == targetCapacity || contain2 == targetCapacity || contain1 + contain2 == targetCapacity) {
                    return true;
                }
                visited.add(cur);
                long[] states = new long[6];
                // 清空第一个杯子
                states[0] = cur & mask2;
                // 清空第二个杯子
                states[1] = cur & mask1;
                // 装满第一个杯子
                states[2] = ((long) jug1Capacity << 32) | contain2;
                // 装满第二个杯子
                states[3] = (cur & mask1) | jug2Capacity;
                // 把第一个杯子里的水全部倒进第二个杯子
                // 装得下就全部转移，装不下就装满为止
                long move = jug2Capacity - contain2 - contain1 >= 0 ? contain1 : jug2Capacity - contain2;
                states[4] = ((contain1 - move) << 32) | (contain2 + move);
                // 把第二个杯子里的水全部倒进第一个杯子
                // 装得下就全部转移，装不下就装满为止
                move = jug1Capacity - contain2 - contain1 >= 0 ? contain2 : jug1Capacity - contain1;
                states[5] = ((contain1 + move) << 32) | (contain2 - move);
                for (long state : states) {
                    if (!visited.contains(state)) {
                        stack.push(state);
                    }
                }
            }
            return false;
        }
    }

//runtime:367 ms
//memory:102.8 MB
